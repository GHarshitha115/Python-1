no.of lines increase     ---> we use functions
no.of functions increase ---> we use modules
(Modular Programming) 
Adv:
    1.Breaking large files (simplicity)
    2.More mangable (Easy Maintenance)
    3.Reusability
    4.Scoping
    
---------------------------------------------------------------------------------------------------    

Executing as module

1.It will be executed only once what we have written in the code
2.Because of it when we called it taken as module and printed outcome
>>> import my_module
Hello World
3.When we called it second time then it will not print anything.
>>> import my_module
>>> 

def print_helloworld():
	print('Hello World')

print_helloworld()

gaddam-mahesh:~/environment $ cd python
gaddam-mahesh:~/environment/python $ python3
>>> import my_module
Hello World
>>> import my_module
>>> 
>>> 

---------------------------------------------------------------------------------------------------    

Executing as script

1.Running the entire files.

gaddam-mahesh:~/environment $ cd python
gaddam-mahesh:~/environment/python $ python3 my_module.py
Hello World
gaddam-mahesh:~/environment/python $ python3 my_module.py
Hello World



---------------------------------------------------------------------------------------------------    

How to reload the module without exit() in interpreter:

def print_helloworld():
	print('Hello World')

def print_one():
	print('1')

print(__name__)

print_helloworld()
print_one()

let us assume that we have assed a function in the module where you are already in the interpreter but you have to check whether it then:

we use:
*Reloading module contd..*
->Using reload function from importlib to reload module again.

Take an example that i have added a function print_one:
->so in line 6 i wanted to get the output but i have already in the interpreter,so it throws error(AttributeError: module 'my_module' has no attribute 'print_one')
->So by using the reload module control we get output i.e (print_one()),unless without using this function it throws error.
  >>> from importlib import reload
  >>> reload(my_module)



1.>>> import my_module
2.Hello World
3.>>> import my_module
4.>>>
5.>>> my_module.print_helloworld()
Hello World
6.>>> my_module.print_one()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: module 'my_module' has no attribute 'print_one'
7.>>> from importlib import reload
8.>>> reload(my_module)
my_module
Hello World
<module 'my_module' from '/home/ec2-user/environment/python/my_module.py'>
9.>>> from importlib import reload
10.>>> reload(my_module)
my_module
Hello World
<module 'my_module' from '/home/ec2-user/environment/python/my_module.py'>
11.>>> my_module.print_one()



-------------------------------------------------------------------------------------------------------

gaddam-mahesh:~/environment $ cd python_sample_package
gaddam-mahesh:~/environment/python_sample_package $ cd ..
gaddam-mahesh:~/environment $ cd python_sample_package/
gaddam-mahesh:~/environment/python_sample_package $ python3
Python 3.6.8 (default, Aug  2 2019, 17:42:44) 
[GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linux
Python 3.6.8 (default, Aug  2 2019, 17:42:44) [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import echo
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ModuleNotFoundError: No module named 'echo'
>>> import sound.effects
sound package is getting imported!
effects package is getting imported!
>>> import sound.effects.echo
Module echo.py has been loaded!
>>> import sound.effects.echo.fun1()
  File "<stdin>", line 1
    import sound.effects.echo.fun1()
                                  ^
SyntaxError: invalid syntax
>>> sound.effects.echo.fun1()                    
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: module 'sound.effects.echo' has no attribute 'fun1'
>>> sound.effects.echo.func
sound.effects.echo.func1(
sound.effects.echo.func2(
sound.effects.echo.func3(
>>> sound.effects.echo.func
sound.effects.echo.func1(
sound.effects.echo.func2(
sound.effects.echo.func3(
>>> sound.effects.echo.func1(
... 
... 
... 
... )
echo function func1 has been called!
>>> sound.effects.echo.func2()
echo function func2 has been called!
>>> sound.effects.echo.func3()                   
echo function func3 has been called!
>>> from sound.effects import echo
>>> echo.fun1()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: module 'sound.effects.echo' has no attribute 'fun1'
>>> echo.func1()
echo function func1 has been called!
>>> from sound.effects import reverse
Module reverse.py has been loaded!
>>> reverse.func1()
reverse function func1 has been called!
>>> from sound.filters import equalizer
filters package is getting imported!
Module equalizer.py has been loaded!
>>> equalizer.fuc1()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: module 'sound.filters.equalizer' has no attribute 'fuc1'
>>> equalizer.func1()
equalizer function func1 has been called!
  File "<stdin>", line 1
    from sound.effects.echo from func1
                               ^
SyntaxError: invalid syntax
>>> from sound.effects.echo import func1         
>>> fun1()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'fun1' is not defined
>>> func1()
echo function func1 has been called!
>>> from sound.effects.echo import *
>>> func2()
echo function func2 has been called!
>>> func3()
echo function func3 has been called!
>>> func1()
echo function func1 has been called!
>>> func3()
echo function func3 has been called!
>>> from sound.effects
sound.effects
>>> from sound.effects.
sound.effects.echo     sound.effects.reverse  
>>> from sound.
sound.effects  sound.filters  
>>> from sound.effects import *
>>> echo.func
echo.func1(  echo.func2(  echo.func3(  
>>> echo.func1()
echo function func1 has been called!
>>> from sound.effects import *
>>> 
>>> from importlib import reload
>>> reload(sound)
sound package is getting imported!
<module 'sound' from '/home/ec2-user/environment/python_sample_package/sound/__init__.py'>
>>> from sound.effects import *                                                                                                  
>>> exit()
gaddam-mahesh:~/environment/python_sample_package $ pythom3
bash: pythom3: command not found
gaddam-mahesh:~/environment/python_sample_package $ python3
Python 3.6.8 (default, Aug  2 2019, 17:42:44) 
[GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from sound.effects import *                                                                      
sound package is getting imported!
effects package is getting imported!
Module echo.py has been loaded!
Module reverse.py has been loaded!
Module surround.py has been loaded!
>>> from importlib import reload
>>> reload(sound)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'sound' is not defined
>>> from sound.effects import *
>>> exit()
gaddam-mahesh:~/environment/python_sample_package $ python3
Python 3.6.8 (default, Aug  2 2019, 17:42:44) 
[GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from sound.effects import *
sound package is getting imported!
effects package is getting imported!
Module echo.py has been loaded!
Module reverse.py has been loaded!
>>> from importlib import reload
>>> reload(sound.effects)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'sound' is not defined
>>> reload(echo)
Module echo.py has been loaded!
<module 'sound.effects.echo' from '/home/ec2-user/environment/python_sample_package/sound/effects/echo.py'>
>>> 
>>> 
>>> 
>>> from sound.effects import *


-------------------------------------------------------------------------------------------------------

import random
#value = random.randint(0,1)
#print(value)
'''
greeting = ['Hello','Hi','Hey','Howdy','Hola']
value = random.choice(greeting)
print(value+' Mahi!')

colors = ['Red',"Black","Blue"]
results = random.choice(colors,weights=[50,50,75],k=10)
print(results)'''
deck = list(range(1,53))

#random.shuffle(deck )

print(deck)


-----------------------------------------------------------------------------------------------------------

import datetime

tdy = datetime.date.today()
print(tdy)
print(tdy.day)
print(tdy.weekday())
print(tdy.isoweekday())



import datetime

tdy =datetime.date.today()

#tdelta = datetime.timedelta(days=7)

#print(tdy+tdelta)

#print(tdy-tdelta)

#timedelta is used to get differences or adding of time and represented as (tdelta)

#date2 = date1 + timedelta
#timedelta = date1 + date2

bday = datetime.date(2020 , 5 ,14)

till_bday=bday-tdy#this is time delta where we are using it to differences

print(till_bday)

print(till_bday.total_seconds())


import datetime 

dt = datetime.datetime(2016,12,31,12,35,45,1000)

tdelta = datetime.timedelta(days=7)

print(dt)

print(dt+tdelta)

import datetime
import pytz


#dt_today = datetime.datetime.today()
#dt_now = datetime.datetime.now()
#dt_utcnow = datetime.datetime.utcnow()

#print(dt_today)
#print(dt_now)
#print(dt_utcnow)

#dt = datetime.datetime(2016,7,26,12,30,45,tzinfo=pytz.UTC)
#print(dt)

#dt_now = datetime.datetime.now(tz=pytz.UTC)
#print(dt_now)

#dt_utcnow = datetime.datetime.utcnow().now(tz=pytz.UTC)
#print(dt_utcnow)

#for tz in pytz.all_timezones:
#	print(tz)

#dt_india = datetime.datetime.now()
#dt_east = dt_india.astimezone(ptyz.timezone('US/Eastern'))
#print(dt_east)
#print(dt_india)

dt_india = datetime.datetime.now(tz=pytz.timezone('US/Mountain'))
#india_tz = pytz.timezone('')
print(dt_india.strftime('%B %d %Y'))

dt_str = 'March 04 2020'

dt = datetime.datetime.strptime(dt_str,'%B %d %Y')
print(dt)

#strftime - datetime_to_string
#strptime - string_to_datetime

-----------------------------------------------------------------------------------------------

def cheeseshop(item,*arguments,**keywords):              
    print('--What kind of item do you want,sir?',item)
    print('--We are out of that item',item)
    for arg in arguments:
        print(arg)
    print('-'*40)
    for kw in keywords:
        print(kw,':',keywords[kw])




cheeseshop("Limburger", "It's very runny, sir.",  
           "It's really very, VERY runny, sir.",
           shopkeeper="Michael Palin",
           client="John Cleese",
           sketch="Cheese Shop Sketch")

#(*arguments)--take any number of arguments.
#(**keywords)--take (key,value)pair as tuple format.
#When we are calling the function if we pass parameters as 
        cheeseshop("Limburger",
           shopkeeper="Michael Palin",
           client="John Cleese",
           sketch="Cheese Shop Sketch",
           "It's very runny, sir.",  
           "It's really very, VERY runny, sir.",)
and formal arguments are taken as fun(item,**keywords,*arguments)--Then it throws syntax error because it consists of format
(Positional argument,Key word argument,Positional argument)

-----------------------------------------------------------------------------------------------

We can use the zip file to pack known ,Unknown by the taking the inputs for 
Ex:
    
    Ques=['Name','Age','Gender']
    Ans =input('Name,Age,Gender:').split(',')
    for q,a in zip(Ques,Ans):
        print(f'What is your {q}?,  It is {a}')
    
    output:
    Name,Age,Gender:mahi,22,M
    What is your Name?,  It is mahi
    What is your Age?,  It is 22
    What is your Gender?,  It is M

-----------------------------------------------------------------------------------------------

def fib(n):
    a,b=0,1
    while a<n:
        print(a,end=' ')
        a,b=b,a+b
    print()

fib(5)
 
-----------------------------------------------------------------------------------------------
           
import json 

user_data='''{ "people":[
                        {
                            "name":"mahi",
                            "age":"22",
                            "Licence":true
                        },
                        {
                            "name":"rakesh",
                            "age":"23",
                            "Licence":false
                        }
                        ]}'''

data = json.loads(user_data)
print(data)
print(type(data['people']))
#print(data)
for user in data['people']:
    del user['age']



By using the loads we can load the string kind of data into the json :

Steps to convert the dictionary stored objects into the string (i.e to load the data to json ):
1.Use the multi-string line quotes to convert to a string.
2.If it is dictionary then use the (" ")double quotes to take the (variables)key,values.
3.To do opearrtions on the string that is loaded into json we can convertit to list and perform the operations.
Ex:   print(type(data['people']))   #Converted to list.
4.Operations performed ==>for user in data['people']:
                              del user['age']


Then to convert the data back to the object that is taken we can use the keyword 'json.dumps'

1.We can simply write to check the data is converted or not by 
    new_string = json.dumps(data)
Where this will give a single line output,To overcome this we use "indent" so that we can set the intendations
    new_string = json.dumps(data,indent=2)
Where this will be printed with proper intendation we set but to sort the values or keys we use the "sort_keys" or "sort_items".
    new_string = json.dumps(data,indent=2,sort_keys=True)
new_string = json.dumps(data,indent=2,sort_keys=True)

print(new_string)

Output:
        #<class 'list'> where as type will be list while we perform in the  list          vvvf
{
    "people": [
    {
      "Licence": true,
      "name": "mahi"
    },
    {
      "Licence": false,
      "name": "rakesh"
    }
        ]
}

-----------------------------------------------------------------------------------------------

import os
os.mkdir('OS-Demo-2') #create a file in the current repositary
os.rmdir('OS-Demo-2') #Delete a file in the current repositary
print(os.listdir())   #To get the entire files like a list that are in the repositary we use the syyntax=>os.listdir()


#To know the dirpath,dirnames,filenames we use the syntax => os.walk('Path-name')
we get in the format of three tuples and here we get the three values i.e written in the loops
It started at the currect path and it goes into each file in the environment and untill the tree ends it will print the data.


for dirpath,dirnames,filenames in os.walk('/home/ec2-user/environment'):
    print('Current Path:',dirpath)
    print('Directories:',dirnames)
    print('Files:',filenames)
    print()
  
Use:
    You know you missed a file you can check through the os.walk() method or get the tree structure
           


print(os.environ.get('HOME'))
=> We can get the home directory by printing the above line we will get the home directory(i.e '/home/ec2-user' is my home directory)

os.path(MODULE)
=>It is easy to define paths of the directory by using this 

file_path = os.path.join(os.environ.get('HOME'),'text.txt')
print(file_path)

os.path.exit('path')#To check whether this file exits or not
os.path.file('path')

print(dir(os.path)) #To check the different of methods in this os.path methods.

#os.path.join is used to get the path correctly where the relative path is given correctly including '/'.
file_path = os.path.join(os.environ.get('HOME'),'text.txt')
print(file_path)
output:     
       /home/ec2-user//text.txt



